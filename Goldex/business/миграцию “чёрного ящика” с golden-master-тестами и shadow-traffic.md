## 1. Зафиксировать текущее поведение Go-сервиса

**Цель:** превратить текущий сервис в “истину”, включая баги.

1. **Заморозить фичи**
    
    - На время миграции — только багфиксы по критическим проблемам.
        
2. **Собрать описание API**
    
    - OpenAPI/Swagger (если нет — сгенерировать по факту).
        
    - Для каждого метода: путь, метод, query, body, заголовки, коды ошибок, формат ошибок.
        
3. **Включить расширенный лог**
    
    - Логировать: `request (headers+body)`, `response (status+headers+body)`, время ответа.
        
    - Дополнительно: SQL/queue-side-effects (по ключевым endpoint’ам).
        

---

## 2. Построить “golden master” (набор эталонных тестов)

**Идея:** любые входные данные → должны давать тот же выход (даже если это баг).

1. **Собрать реальные запросы**
    
    - Выгрузка N тысяч типичных/краевых запросов из логов.
        
    - Плюс ручные кейсы по известным багам/углам.
        
2. **Прогнать их через Go-сервис и сохранить ответы**
    
    - Сохранить: статус, заголовки, тело, время ответа (для статистики).
        
3. **Обёртка-тестер**
    
    - Скрипт/сервис, который:
        
        - берёт набор `requests.jsonl`,
            
        - шлёт на сервис,
            
        - сравнивает с эталонным `responses.jsonl` (с маскировкой полей типа timestamp/trace_id).
            

Это и есть “контракт”, который Node-версия обязана выполнить.

---

## 3. Проект Node.js под этот контракт

1. **Сохранить API 1:1**
    
    - Те же пути, методы, параметры, форматы JSON, коды ошибок, текст сообщений.
        
    - Те же HTTP-заголовки (минимум: `Content-Type`, ошибки, кэш-заголовки).
        
2. **Сохранить хранилища и побочные эффекты**
    
    - Либо:
        
        - Node ходит в ту же БД/очереди, что и Go,
            
    - либо:
        
        - вводится слой совместимости, который гарантирует такой же SQL/сообщения, как раньше.
            
3. **Технические детали**
    
    - Фреймворк (Express/Fastify/Nest) — не важно, главное: поведение endpoint’ов совпадает.
        
    - Все конфиги (ports, env, feature-flags) сделать максимально изоморфными с Go-версией.
        

---

## 4. Проверка эквивалентности

### 4.1. Автотесты против обоих сервисов

1. **Запуск Go и Node параллельно**
    
    - Например:
        
        - Go: `http://go-svc:8080`
            
        - Node: `http://node-svc:8081`
            
2. **Golden-master-тест**
    
    - Для каждого запроса:
        
        - отправить в Go и в Node,
            
        - сравнить ответы с учётом:
            
            - игнорируемых полей (время, request_id),
                
            - допустимой разницы в порядке полей JSON.
                
3. **Unit/интеграционные тесты**
    
    - Плюс обычные юниты для Node-кода, но главное — пройти golden-master.
        

### 4.2. Shadow-traffic из продакшена

1. **Прокси перед Go-сервисом** (nginx/Envoy/Traefik/свой gateway)
    
    - Реальный ответ идёт от Go.
        
    - Копия каждого запроса асинхронно уходит в Node.
        
2. **Сравнение оффлайн**
    
    - Логировать пары ответов (Go vs Node).
        
    - Анализировать расхождения, пока их не станет 0 (или только в явно разрешённых местах).
        

---

## 5. Невидимая замена в проде

Когда расхождений нет:

1. **Canary-режим**
    
    - 1–5% трафика (по пользователям/tenant’ам/токенам) обслуживает уже Node, остальные — Go.
        
    - Метрики: ошибки, латентности, ресурсопотребление.
        
2. **Постепенное увеличение**
    
    - 5% → 25% → 50% → 100%.
        
    - При любой аномалии — быстрый rollback через прокси.
        
3. **Финальный свитч**
    
    - Node становится основным.
        
    - Go остаётся рядом в “read-only / backup” режиме ещё какое-то время (для отладки редких кейсов).
        

---

## 6. “Включая баги” — как это формализовать

1. **Все известные баги → явные тесткейсы**
    
    - “Неправильный округлённый результат”, “странный порядок сортировки”, “невалидный JSON в редком случае” — если клиент уже живёт с этим, это фиксируем в golden-master.
        
2. **Разделить режимы**
    
    - В будущем можно сделать:
        
        - `v1` — полная совместимость (со странностями),
            
        - `v2` — “починенная” логика с другими контрактами.
            
3. **Любое изменение поведения = breaking-change**
    
    - Значит или новая версия API, или фича-флаг.
        

---

## 7. Мини-чек-лист “Definition of Done”

-  Есть зафиксированное описание API.
    
-  Собран большой набор реальных запросов.
    
-  Есть golden-master-набор ответов от Go.
    
-  Node-сервис проходит golden-master локально.
    
-  Shadow-traffic показывает 0 (или строго допустимый список) расхождений.
    
-  Пройден canary rollout без деградации метрик.
    
-  Есть план быстрого rollback.
    

---

Если хочешь, дальше можем:

- адаптировать это под твой конкретный стек (какой Go-фреймворк, какая БД),
    
- или набросать структуру репо и тест-раннер для golden-master.